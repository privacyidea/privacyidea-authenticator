# privacyIDEA Authenticator

The privacyIDEA Authenticator supports one time passwords
based on the [HOTP](https://tools.ietf.org/html/rfc4226) and the [TOTP](https://tools.ietf.org/html/rfc6238) algorithms.

In addition to HMAC-SHA1, which is specified in RFC4226 it also
supports HMAC-SHA256 and HMAC-SHA512.

The authenticator app uses the [KeyURI defined by Google](https://github.com/google/google-authenticator/wiki/Key-Uri-Format) to scan the symmetric OTP seed via a QR-Code into the app.

## Secure Two Step Enrollment

The privacyIDEA Authenticator allows you to use a more secure enrollment process.
The original KeyURI concept by Google was simple but [allowed for an easy copying of the OTP seed](https://netknights.it/en/the-problem-with-the-google-authenticator/), as the
OTP seed is contained in plain text (base32 encoded) in the URI.

The privacyIDEA Authenticator allows you to enroll the token in two steps, where the final OTP seed is composed from
a seed component generated by the server and a second part generated by the smartphone. This way the OTP token is
bound to one smartphone and can not be enrolled on several different devices.

This documentation should help you to

1. Implement the enrollment concept into your own authenticator app, so that your app will work smoothly with the privacyIDEA backend.

2. Implement the enrollment concept into your own backend, so that the privacyIDEA authenticator will work smoothly with your application or backend.

## Enhanced Key URI parameters

In addition to the original Key URI parameters the privacyIDEA Authenticator accepts the following parameters.

If the Key URI contains one of the parameters ``2step_output``, ``2step_salt`` or ``2step_difficulty`` the app 
will create a random value to be used to calculate the resulting OTP seed in conjunction with the ``secret`` parameter.
Read more about key generation in the section below.

### 2step_output

This parameter specifies the length of the resulting OTP seed.
Usually you do not have to specify this parameter. It is 160 (bit) for HMAC-SHA1, 256 (bit) for HMAC-SHA256 and 512 (bit)
for HMAC-SHA512.

    2step_output=160


### 2step_salt

The parameter ``2step_salt`` defines the length of the random salt generated by the app that will be used with the
``secret`` parameter to calculate the OTP seed.

    2step_salt=2

The paramter takes an integer as the byte length of the generated salt. Please note, that the app will also display 
a checksum, so that ``2step_salt=2`` will actually create a longer string.

You should not choose a value to high, so that the users do not complain about entering a two long value.
You should not choose a value to low, to not compromize the security of the enrollment process.

The default value is 10 (bytes).

[alte](qrcodes/2step.png)

### 2step_difficulty

The calculation of the resulting OTP seed uses PBKDF2. The ``2step_difficulty`` specifies the number of rounds, that will 
be used to calculate the resulting OTP seed.

    2step_difficulty=20000

The default value is 10.000. 

But a value of 2.000.000 takes also only roughly 5 seconds to calculate the OTP seed on a current smartphone.

### pin

If the administration wants the user to protect the token with a password, the backend can set the flag ``pin``.
The user will have to set a pin in the app for this very token,
before he sees the first OTP value and can actually use this token.

    pin=true


### taptoshow

If this parameter is set, the OTP value will only be shown, after the user tapped the token.

    taptoshow=true
    
### undeletable

If the administration wants to avoid, that the user deletes a token from his app by accident. The backend can set the ``undeletable``
flag in the Key URI. This way the user can not delete the token from the smartphone app.

    undeletable=true


## Calculation of the OTP seed

The OTP seed is the secret, symmetric key that is used
in the HOTP or TOTP algorithm to calculate the OTP values.
In 2step enrollment the app calculates this OTP seed from the server
component (contained in the paramter ``secret``) and from
the app component, generated by the app.

The user has to pass the app component back to the server and 
both app and server have to calculate the OTP seed
accordingly.

In the basic configuration the OTP seed is calculated like this:

    otpseed = pbkdf2(server_component, app_component, 2step_difficulty, 2step_output)

with ``server_component`` being the ``secret`` from the QR Code and ``app_component``
being the salt generated by the app.


The implementation of the privacyIDEA Server key calculation can 
be found here. https://github.com/privacyidea/privacyidea/blob/master/privacyidea/lib/tokens/hotptoken.py#L712


### Checksum

The app component contains a checksum, the server should
verify this checksum.

The app component is prefixed with the first 4 bytes of the 
app component itself.
This value is then base32 encoded, to be sent to the 
privacyIDEA server during enrollment.

    app_component = base32(sha1(app_component)[:4] + app_component)

The server implementation can this way check that the 
user did not enter a wrong app component.